#Ch10 Design Patterns(2)
##一、信息隐藏
###1.信息隐藏的秘密：内部实现与外部行为
以家庭影院为例，见ppt
####层次结构面向对象  
* 对象应当是平等的，实际上很难产生包含关系的层次结构
* 模块的接口具有非结构化特征  
各接口独立，由多个类的不同接口组合
####Facade模式
#####实现方式
* 逻辑上实现了一个很大的类  
包含很多细节  
实际是聚合关系，代码实现时没有区别，只在语义上有区分
* 实现上将一个模块分解成多个类  
小类都作为其成员变量
* 所有方法都是委托出去的
#####解决的问题
* 给模块或子系统提供整体接口，代替原先零碎、复杂的接口
* 提供更高层次的接口，使整个模块使用起来更容易  
隐藏了内部实现
#####解决方案
* 没有具体的solution
* 只是一种结构示意
#####注意事项
* 部分类的整体性是Facade模式的特征
* Facade与Controller有所不同
	* 控制器用于将UI和逻辑解耦  
	底下不是复杂结构，只是一对一的转发，通常只发生在UI与逻辑层中
	* Facade用于聚合复杂结构  
	应用中多见于数据层的**聚合**
* 不是所有模块都能使用Facade模式的  
并非所有模块都能够聚合
* UML 2.0的复合类就对应于一个Facade
###3.另一个秘密：变更
####策略模式
* 持有多个候选算法以解决**一个**问题的对象
* 此处算法的概念很宽泛，不妨理解为多种行为
####注意事项
* 策略模式中，使用**聚合关系**，而非关联  
策略本身并不独立，只是因预防变化而将其从Context中抽取出来
* 多个差异性，就建立多棵策略树
* 对行为组的差异性，仍然采用单策略树，但包含整组方法
* 对象集部分属性的差异性，
* 对象集一个行为需要的协作对象的差异性，将此行为建立策略数
* 对象集的行为因为属性的取值存在差异性，使用**状态模式**  
见下
####使用时机
* 多个相关的类，只在单个行为上有不同
* 一个类定义多种行为，且执行中使用多个判断条件
* 需要多种差异算法
* 一些数据不希望对外暴露

前三个都是典型的差异性特征
##二、共性与差异性
###1.特征图
* Required features
* Optional features
* Open/closed
* Alternative features
* n of m features
####共性
需求是肯定的，不会变化
####差异性
* 从需求上看，功能可有可无，可多可少
* 简单的if通常不能有效使用
* **能处理差异性，就能处理可变更性**
###2.以汽车为例
####多态（继承）处理差异性
* 公共部分放在父类
* 差异部分放在子类
* 有几种差异性，就有几层继承结构
* 只能处理若干选一的问题  
多选多需要进行人为处理，这就是其局限性
####聚合处理差异性
* 整体负责共性
* 部分负责差异性  
由于**策略模式**解决的就是差异性的问题，因此策略模式在这里也可以使用

*继承会导致类结构过于庞大，因此实现上更倾向于使用聚合而不是继承*
###3.状态模式
####使用时机
* 对象的行为因状态的改变而改变
* 多选判断时
####效果
* 状态变化本地化
* 状态转移更明显
* 状态对象可以共享
####Strategy与State的区别
#####n选1与n选m
状态模式也可以包含多种状态，此时称为*fuzzy state*
#####状态由谁转换
***转换的信息在哪里，转换的动作就在哪里***
#####如何转换状态
大量if语句必然是无法消除的，只是希望将其转移，避免重复耦合，使风险可控

* 固定规则
* 配置文件
#####创建与销毁策略
根据实际情况进行判定，1..1与0..1、n..m的基数都会产生不同策略
###4.桥接模式
接口与实现都存在差异时使用
####实现方式
* 将接口与实现以**聚合**的方式**绑定**起来  
实现可以轻易地变化
* 接口的不同通过继承来解决
####解决的问题
* 以往通过继承将实现与接口绑定在一起  
但这种*永久绑定*不够灵活
* 将实现与抽象单独独立开来  
本质仍然是策略，只不过在其基础上又封装了接口的变化
####效果
* 将接口与实现相分离  
*Abstraction*与*Implemention*
* 提高可扩展性
* 对client隐藏细节