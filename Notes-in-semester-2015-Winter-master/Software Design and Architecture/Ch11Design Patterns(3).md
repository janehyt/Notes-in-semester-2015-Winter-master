#Ch11 Design Patterns(3)
##一、间接化（解耦）
###1.解耦的方式
* 避免重复  
将相同的代码抽象出来
* DIP（依赖倒置）  
抽象不能依赖于具体，而是具体依赖于抽象，即应当依赖于稳定的对象
* 间接化
###2.适配器模式
####解决问题
* 将一个接口变成Client需要的接口
* 令两个不兼容的接口一同工作
#####应用的常见情景
* 调用操作系统API
* 网络调用
* I/O  
总之就是**对外交互**，交互的代码无法被控制，无法主动重构

总的来说，适配器模式就是要解除不希望产生的耦合
####解决方式
* 使用中间对象避免耦合
* 考虑可变更性，就会产生线性的UML结构
###3.中介模式
####解决的问题
* **很多**对象，可能分类，但都平等，它们按一定的规则互动
* 复用对象与通信非常困难
* 大量行为是分布式的
####实现方式
* 将规则抽取为一个对象  
将所有交互集中起来，需要交互时，将消息提交到Mediator上，再由Mediator通知
* 需要不同的交互方式，就将Mediator做出继承结构
* 对象本身处理功能，不负责后续影响，Mediator控制交互
####效果
* 一个对象将对象之间的交互全部封装起来
* 修改与扩展规则变得很容易
* 提供了松散耦合的处理方式，每个参与者都可以轻易地修改
* 可以提供多种处理方式
* 使用了集中式控制风格，导致Mediator比较复杂
##二、运行时注册
实际上也用于解耦
###1.回调机制
* Client需要调用server，但不知道确切的调用时机；Server掌握调用时机，但不确定调用者是谁
* Client向服务端注册，服务器保存客户端引用，达到某一时机后，服务器通知客户端，客户端再调用服务端
###2.观察者模式
####解决的问题
一（事件源）对多（观察者对象）中，事件源发生变化时，及时通知观察者进行更新
####实现方式
* Observer对Subject的引用在创建时指定，或在更大的上下文函数中设置
* Observer向Subject注册
* Subject中维护observerList
* 有对象触发事件，调用notify()
* Subject逐个调用观察者的方法
####效果
* 具有事件风格的所有特点  
可修改性、灵活性、可重用性
* 更加复杂
####注意事项
#####观察者模式与Event style的不同
观察者模式将服务端与Router绑在一起，因此Router不能太复杂，因而无法处理或于复杂的方式，而且违反单一职责  
轻量级的Event style
#####众多Ovserver的接口不同
实现一棵策略树
###3.命令模式
####解决的问题
* 根据执行的动作讲对象参数化
* 在不同的时间对请求进行鉴别、排队、执行
* 存储上下文信息，支持撤销
* 以日志的形式支持恢复
####实现方式
见ppt
####效果
* 将请求的接受与执行解耦
* 将命令保存在栈或队列中  
命令处理器保存历史记录
* 易于撤销与重复操作  
must add state information to avoid hysteresis
* 命令扩展更容易
