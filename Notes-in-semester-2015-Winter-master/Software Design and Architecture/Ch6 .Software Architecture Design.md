#Ch6 Software Architecture Design
##一、An introduction to architecture design
有体系结构设计之后，体系结构设计取代了概要设计  
###体系结构设计与分析的目的
* 需求的分配  
将需求规格说明中的需求分配到具体的单位  
但未必立即实现  
有些很容易分配，如功能需求，但非功能需求是**散布**的，**互相影响**的，成为最大的困难
* 做出可靠的、有效的体系结构
* 为详细设计和实现奠定良好基础  
体系结构做出的决策为之后的过程提供影响
###带体系结构设计的软件过程
* 需求与体系结构往往同时进行设计与分析  
创意影响结构，结构限制创意
* 体系结构设计完成之后，项目切出几个部分，并行开发

		参考：The Twin Peaks Model
###体系结构设计方法学
通常认为有四个流派，这里讲解用例驱动（需求驱动）的流派

* Style Pattern
* Software Product Line  
找共性和差异性
* RUP  
接近传统做法，将概要设计拿来修补
* Use-case Driven(*)

###SA Design
* 结构
	* 高层设计
	* 4+1 View
* 关注点
	* 质量与环境
* 设计决策
	* Giving solution to factors
* 风格
##二、A simple example
> ######仍然使用第4章的例子
> * 资源管理系统的主要关注点列表
> * 体系结构需求描述  
> ppt中用表格描述，但具体项目中可能要以文本展开
> * 场景的描述
> * 设计决策过程
##三、Software architecture design
###0.C. Hofmeister——全局分析
* 分两条线，先做出体系结构分析文档，再建立初始的体系结构；  
* 对每一条需求进行分配，即做一次决策，最终获得体系结构。  
* 分配完成后，进行体系结构的评估。
###1.体系结构分析
####概要功能需求
####质量属性需求
####项目环境
* 开发环境
	* 人员  
	能力的限制、数量的限制
	* 组织与管理  
	过程、开发工具（有些十分昂贵，有些存在风险）、成本与利益
	* 资源  
	硬件资源、人工数量
* 商业环境  
上市时间、进度安排、市场广度、预计持续时间
* 技术环境  
	* 软件环境  
	操作系统、网络、数据库、需要交互的软件
	* 硬件环境  
	处理器，等等
	* 支撑技术
	* 标准
####商业目标
####定义体系结构需求
* 找到所有需求后，就可以定义体系结构需求  
* 体系结构需求定义时，功能需求可以粗略，但质量、环境和约束必须详细  
一条约束可能会影响多条需求  
* 对每个体系结构需求进行加工后，就能获得场景和用例  
这种情况下的场景描述使用**一般场景方法**  
*在什么环境下，什么刺激源提出了什么刺激，对制品作出了什么响应*
	* 刺激
	* 刺激源
	* 环境
	* 制品
	* 响应
	* 响应的度量 
###2.定义初始体系结构
或者从已有资源中复用，或者从经验和直接直接从头做起  
多数情况下，体系结构不需要从头开始设计
####利用已有资源建立初始软件结构
####从头开始建立初始软件结构
* 利用模块化、信息隐藏等基本设计原则处理功能需求  
这时不要太考虑质量等非功能需求  
初始体系结构做完后，功能需求就已经完成了分配  
####初始体系结构的表示
* 逻辑视图
* 开发视图
* 进程视图
* 部署视图

后面三个视图在初始体系结构中通常不做，因为这个体系结构是**一定会修改的** 
###3.体系结构的建立*
这里的重点是非功能和质量需求的分配，也就是所谓决策的过程  
对初始体系结构进行逐条评估，能够满足需求，就评估下一条；若不能满足，则进行修改。
####评估质量属性
* 模拟
* 数学计算
* 经验推导
####设计决策与过程
* 每个决策过程都可能产生对详细设计的新约束
* 每个决策过程可能会产生新的体系结构约束
##四、Strategies and tactics（不会考）
这部分内容主要体现在决策的部分，为什么做出这样的决策
###1.可靠性
* 故障检测
	* ping与响应  
	在被监控对象上额外添加一个用于监控的端口
	* 心跳  
	关键节点定期向其它结点发送消息，用于表示结点还活着  
	心跳信号可以带有数据  
	Server端做广播，Client端负责接受
	* 异常  
	实质是一种编程策略，但也会影响体系结构  
	要有专门的组件来处理异常
* 故障的准备与恢复
	* 投票算法  
	主要用于防止黑客攻击  
	所有的调用会变成分布式的调用，由一个变成多个  
	*参考：拜占庭算法*
	* 主动冗余  
	双机热备，两台机器都处于运转状态  
	所有组件都需要拷贝一份，同时要有组件负责控制结果的切换
	* 被动冗余  
	产生多个组件，一个组件负责响应，出现故障后以另一个备份切换  
	增加了备份的组件，需要状态同步机制
	* Spare  
	类似上一次正确启动的配置保存  
	一般只在单机系统上使用
* 事后恢复
	* 沙箱模式  
	出现故障后，系统以安全模式启动
	* 状态重同步
	* 回滚
* 防止影响扩大化
	* 从服务中移除  
	一旦发现故障，要立刻对其进行封杀  
	可以与心跳、投票算法结合使用
	* 事务  
	保存现场，捕获异常，全部恢复
	* 进程监控  
	专门的处理模块，发现故障后立即进行处理
###2.可修改性
大二已讲过，这里略过

* 变更本地化
	* 保持语义内聚（高内聚）
	* 预期将来可能发生的改变
	* 模块通用化
	* 限制相互选择的路径
* 阻止连锁反应
	* 信息隐藏
	* 维护已存在的接口  
	**public** interface与**publish** interface的区别
	* 限制通信路径
	* 使用中介
* 延迟绑定
	* 运行时注册
	* 配置文件
	* 多态
	* 组件替换
	* 遵守相同协议
###3.性能
* 资源需求
	* 提升计算效率  
	改进算法  
	空间换时间等权衡  
	可能需要新的组件
	* 减少计算负载  
	噪音数据的过滤  
	计算量的减少  
	数据仓库多维度的设计
	* 控制事件频率
	* 控制采样频率  
	视频的超清/高清/流畅  
	以不同的代理来做不同模式下的采样
* 资源管理
	* 引入并发  
	多进程、多线程，等等等等  
	会改变连接件的方式
	* 增加数据的拷贝  
	提升性能，但需要注意多份数据的一致性  
	请求变为分布式的或是集群式的  
	数据的分布和分片
	* 增加可用资源  
	不停地添加机器和硬件  
	程序的控制上需要支持此功能（负载均衡等）
* 资源抽象
	* 调度策略  
	FIFO、优先级、动态优先数、静态调度……  
	现在的机器不值钱，所以不那么重要了
###4.安全性
* 阻止攻击
	* 验证  
	密码验证、单点登录、数字验证    
	需要新的组件，会影响连接件的设计
	* 授权  
	为不同的用户做访问控制  
	RBAC（基于角色的权限控制）
	* 数据保密性  
	同样可以使用RBAC来控制数据访问  
	数据加密、内存加密
	* 数据一致性  
	通常维护多个部分，操作时检查  
	冗余检查  
	采用触发器、限制等机制来实现
	* 限制暴露  
	将组件与数据分散开来，防止因一次攻击被获取所有数据
	* 限制访问  
	*花点钱买个硬件防火墙就好了*
* 检测攻击
	* 冲突检测、入侵检测  
	对访问行为的数据进行分析，如果这些数据符合某一行为模式，则将其判定为攻击
* 攻击之后的恢复
	* 审计  
	日志的记录
###5.可测试性
* 管理输入/输出
	* record/playback  
	记录方法的参数，失败后检查参数；成功后记录结果
	* 接口与实现分离  
	此处的测试总线技术无论是在开发时还是开发后都是一体化的  
	所有接口都有测试总线与实际接口两个实现
	* 使用特定访问路径  
	设定在某些特定环境下进行的一些特殊操作
* 内部监控
	* 内嵌监控器  
	监控内存区，日志等等因素  
	监控器的编写可能会很复杂